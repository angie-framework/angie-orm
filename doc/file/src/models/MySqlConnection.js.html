<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/models/MySqlConnection.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/benderTheCrime/angie-orm.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div data-ice="classWrap">
  <h2>Class</h2>
  <ul>
    
  <li data-ice="classDoc"><span><a href="class/src/util/$ExceptionsProvider.js~$$InvalidConfigError.html">$$InvalidConfigError</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/$Fields.js~BaseField.html">BaseField</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/BaseModel.js~BaseModel.html">BaseModel</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/FirebaseConnection.js~FirebaseConnection.html">FirebaseConnection</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/MongoDBConnection.js~MongoDBConnection.html">MongoDBConnection</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/MySqlConnection.js~MySqlConnection.html">MySqlConnection</a></span></li>
<li data-ice="classDoc"><span><a href="class/src/models/SqliteConnection.js~SqliteConnection.html">SqliteConnection</a></span></li>
</ul>
</div>



<div data-ice="functionWrap">
  <h2><a href="function/">Function</a></h2>
  <ul>
    
  <li data-ice="functionDoc"><span><a href="function/index.html#static-function-AngieDatabaseRouter">AngieDatabaseRouter</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-Base">Base</a></span></li>
<li data-ice="functionDoc"><span><a href="function/index.html#static-function-runTests">runTests</a></span></li>
</ul>
</div>






</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/models/MySqlConnection.js</h1>
<pre class="source-code line-number"><code class="prettyprint linenums" data-ice="content">/**
 * @module MySqlConnection.js
 * @author Joe Groseclose &lt;@benderTheCrime&gt;
 * @date 8/23/2015
 */

// System Modules
import mysql from                       &apos;mysql&apos;;
import {cyan, magenta, gray} from       &apos;chalk&apos;;
import $LogProvider from                &apos;angie-log&apos;;

// Angie Modules
import BaseDBConnection from           &apos;./BaseDBConnection&apos;;

// {
//     $$DatabaseConnectivityError
// } from                                  &apos;./BaseDBConnection&apos;;
import {
    $$InvalidDatabaseConfigError
} from                                  &apos;../util/$ExceptionsProvider&apos;;

const p = process,
      DEFAULT_HOST = &apos;127.0.0.1&apos;,
      DEFAULT_PORT = 3306;
$LogProvider.mysqlInfo = $LogProvider.info.bind(null, &apos;MySQL&apos;);

class MySqlConnection extends BaseDBConnection {
    constructor(name, database, destructive, dryRun) {
        super(database, destructive, dryRun);
        let db = this.database;

        if (!db.username) {
            throw new $$InvalidDatabaseConfigError(db);
        } else if (!this.connection) {
            this.name = name || this.database.name || this.database.alias;
            this.connection = mysql.createConnection({
                host: db.host || DEFAULT_HOST,
                port: db.port || DEFAULT_PORT,
                user: db.username || &apos;&apos;,
                password: db.password || &apos;&apos;,
                database: this.name
            });

            this.connection.on(&apos;error&apos;, function() {
                if (db.options &amp;&amp; db.options.hardErrors) {
                    throw new $$InvalidDatabaseConfigError(db);
                }
            });

            this.connected = false;
        }
    }
    types(model, key) {
        const field = model[ key ];
        let type = field.type,
            maxLength = &apos;&apos;;
        if (!type) {
            return;
        }
        if (field.maxLength) {
            maxLength = `(${field.maxLength})`;
        }
        switch (type) {
            case &apos;CharField&apos;:
                return `VARCHAR${maxLength}`;

            // TODO support different size integers: TINY, SMALL, MEDIUM
            case &apos;IntegerField&apos;:
                return `INTEGER${maxLength}`;
            case &apos;KeyField&apos;:
                return `INTEGER${maxLength}`;
            case &apos;ForeignKeyField&apos;:
                return `INTEGER${maxLength}, ADD CONSTRAINT fk_${key} FOREIGN KEY(${key}) ` +
                    `REFERENCES ${field.rel}(id) ON DELETE CASCADE`;
            default:
                return undefined;
        }
    }
    connect() {
        let me = this;
        return new Promise(function(resolve) {
            if (me.connected === false) {
                me.connection.connect(function(e) {

                    // TODO add this back in?
                    if (e) {
                        // throw new $$DatabaseConnectivityError(me.database);
                        $LogProvider.error(e);
                    } else {
                        me.connected = true;
                        $LogProvider.mysqlInfo(&apos;Connection successful&apos;);
                    }
                });
            }
            resolve();
        });
    }
    disconnect() {
        this.connection.end();
        this.connected = false;
    }
    run(query, model) {
        let me = this,
            name = this.name;
        return this.connect().then(function() {
            return new Promise(function(resolve) {
                $LogProvider.mysqlInfo(
                    `Query: ${cyan(name)}: ${magenta(query)}`
                );
                return me.connection.query(query, function(e, rows = []) {
                    if (e) {
                        $LogProvider.warn(e);
                    }
                    resolve([ rows, e ]);
                });
            });
        }).then(function(args) {
            return me.$$queryset(model, query, args[0], args[1]);
        });
    }
    all() {
        const query = super.all.apply(this, arguments);
        return this.run(query, arguments[0].model);
    }
    create() {
        const query = super.create.apply(this, arguments);
        return this.run(query, arguments[0].model);
    }
    delete() {
        const query = super.delete.apply(this, arguments);
        return this.run(query, arguments[0].model);
    }
    update() {
        const query = super.update.apply(this, arguments);
        return this.run(query, arguments[0].model);
    }
    raw(query, model) {
        return this.run(query, model);
    }
    sync() {
        let me = this;

        // Don&apos;t worry about the error state, handled by connection
        return super.sync().then(function() {
            let models = me.models(),
                proms = [];

            for (let model in models) {

                // Fetch models and get model name
                let instance = models[ model ],
                    modelName = instance.name || instance.alias ||
                        me.$$name(model);

                // Run a table creation with an ID for each table
                proms.push(me.run(
                    `CREATE TABLE \`${modelName}\` ` +
                    &apos;(`id` int(11) NOT NULL AUTO_INCREMENT, &apos; +
                    &apos;PRIMARY KEY (`id`) &apos; +
                    &apos;) ENGINE=InnoDB DEFAULT CHARSET=latin1;&apos;
                ));
            }
            return Promise.all(proms).then(function() {
                return me.migrate();
            });
        });
    }
    migrate() {
        let me = this;
        return super.migrate().then(function() {
            return me.run(&apos;SHOW TABLES&apos;).then((queryset) =&gt; queryset);
        }).then(function(queryset) {
            // const modelMap = [
            //     for (model of queryset) model[ `Tables_in_${me.name}` ]
            // ];
            const modelMap = queryset.map((v) =&gt; v[ `Tables_in_${me.name}` ]);
            let models = me.models(),
                proms = [];
            for (let key of modelMap) {
                let prom;
                if (!models.hasOwnProperty(key)) {

                    // Don&apos;t consolidate, we don&apos;t want to look at the fields
                    if (me.destructive) {
                        prom = me.run(`DROP TABLE \`${key}\`;`);
                    }
                } else {
                    const model = models[ key ],
                          modelName = me.$$name(model.name || model.alias),
                          fields = model.$fields();
                    prom = me.run(
                        `SHOW COLUMNS from \`${modelName}\`;`,
                        modelName
                    ).then(function(queryset) {
                        let proms = [];
                        queryset.forEach(function(v) {
                            if (
                                fields.indexOf(v.Field) === -1 &amp;&amp;
                                v.Field !== &apos;id&apos; &amp;&amp;
                                me.destructive
                            ) {
                                let baseQuery = `ALTER TABLE \`${modelName}\` `,
                                    query =
                                        `${baseQuery}DROP COLUMN \`${v.Field}\`;`,
                                    keyQuery;
                                if (v.Key) {
                                    keyQuery =
                                        `${baseQuery}DROP FOREIGN KEY ` +
                                        `\`fk_${v.Field}\`;`;
                                }
                                if (!me.dryRun) {
                                    let prom;
                                    if (keyQuery) {
                                        prom = me.run(keyQuery).then(
                                            () =&gt; me.run(query)
                                        );
                                    } else {
                                        prom = me.run(query);
                                    }
                                    proms.push(prom);
                                } else {
                                    $LogProvider.mysqlInfo(
                                        `Dry Run Query: ${gray(`${keyQuery} ${query}`)}`
                                    );
                                }
                            }
                        });

                        // TODO you&apos;ve got to return if many to many here
                        fields.forEach(function(v) {
                            if (model[ v ].type === &apos;ManyToManyField&apos;) {
                                return;
                            }
                            if (queryset.map(($v) =&gt; $v.Field).indexOf(v) === -1) {
                                let query,
                                    $default;
                                if (model[ v ].default) {
                                    $default = model[ v ].default;
                                    if (typeof $default === &apos;function&apos;) {
                                        $default = $default();
                                    }
                                }
                                query =
                                    `ALTER TABLE \`${modelName}\` ADD COLUMN \`${v}\` ` +
                                    `${me.types(model, v)}` +
                                    `${model[ v ].nullable ? &apos;&apos; : &apos; NOT NULL&apos;}` +
                                    `${model[ v ].unique ? &apos; UNIQUE&apos; : &apos;&apos;}` +
                                    `${$default ? ` DEFAULT &apos;${$default}&apos;` : &apos;&apos;};`;
                                if (!me.dryRun) {
                                    proms.push(me.run(query));
                                } else {
                                    $LogProvider.mysqlInfo(
                                        `Dry Run Query: ${gray(query)}`
                                    );
                                }
                            }
                        });
                        return Promise.all(proms);
                    });
                }
                proms.push(prom);
            }
            return Promise.all(proms);
        }).then(function() {
            me.disconnect();
            $LogProvider.mysqlInfo(
                `Successfully Synced &amp; Migrated ${cyan(me.name)}`
            );
            p.exit(0);
        });
    }
}

export default MySqlConnection;</code></pre>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.1.2)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
